{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/subscribables/dependentObservable.js"],"names":[],"mappings":"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","file":"dependentObservable-compiled.js","sourcesContent":["var computedState = ko.utils.createSymbolOrString('_state');\n\nko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {\n    if (typeof evaluatorFunctionOrOptions === \"object\") {\n        // Single-parameter syntax - everything is on this \"options\" param\n        options = evaluatorFunctionOrOptions;\n    } else {\n        // Multi-parameter syntax - construct the options according to the params passed\n        options = options || {};\n        if (evaluatorFunctionOrOptions) {\n            options[\"read\"] = evaluatorFunctionOrOptions;\n        }\n    }\n    if (typeof options[\"read\"] != \"function\")\n        throw Error(\"Pass a function that returns the value of the ko.computed\");\n\n    var writeFunction = options[\"write\"];\n    var state = {\n        latestValue: undefined,\n        isStale: true,\n        isBeingEvaluated: false,\n        suppressDisposalUntilDisposeWhenReturnsFalse: false,\n        isDisposed: false,\n        pure: false,\n        isSleeping: false,\n        readFunction: options[\"read\"],\n        evaluatorFunctionTarget: evaluatorFunctionTarget || options[\"owner\"],\n        disposeWhenNodeIsRemoved: options[\"disposeWhenNodeIsRemoved\"] || options.disposeWhenNodeIsRemoved || null,\n        disposeWhen: options[\"disposeWhen\"] || options.disposeWhen,\n        domNodeDisposalCallback: null,\n        dependencyTracking: {},\n        dependenciesCount: 0,\n        evaluationTimeoutInstance: null\n    };\n\n    function computedObservable() {\n        if (arguments.length > 0) {\n            if (typeof writeFunction === \"function\") {\n                // Writing a value\n                writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n            } else {\n                throw new Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n            }\n            return this; // Permits chained assignments\n        } else {\n            // Reading the value\n            ko.dependencyDetection.registerDependency(computedObservable);\n            if (state.isStale || (state.isSleeping && computedObservable.haveDependenciesChanged())) {\n                computedObservable.evaluateImmediate();\n            }\n            return state.latestValue;\n        }\n    }\n\n    computedObservable[computedState] = state;\n    computedObservable.hasWriteFunction = typeof writeFunction === \"function\";\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(computedObservable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(computedObservable);\n\n    // Inherit from 'computed'\n    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);\n\n    if (options['pure']) {\n        state.pure = true;\n        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription\n        ko.utils.extend(computedObservable, pureComputedOverrides);\n    } else if (options['deferEvaluation']) {\n        ko.utils.extend(computedObservable, deferEvaluationOverrides);\n    }\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](computedObservable, true);\n    }\n\n    if (DEBUG) {\n        // #1731 - Aid debugging by exposing the computed's options\n        computedObservable[\"_options\"] = options;\n    }\n\n    if (state.disposeWhenNodeIsRemoved) {\n        // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n        // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n        // we'll prevent disposal until \"disposeWhen\" first returns false.\n        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n        // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try\n        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n        // be documented or used by application code, as it's likely to change in a future version of KO.\n        if (!state.disposeWhenNodeIsRemoved.nodeType) {\n            state.disposeWhenNodeIsRemoved = null;\n        }\n    }\n\n    // Evaluate, unless sleeping or deferEvaluation is true\n    if (!state.isSleeping && !options['deferEvaluation']) {\n        computedObservable.evaluateImmediate();\n    }\n\n    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is\n    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).\n    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {\n        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {\n            computedObservable.dispose();\n        });\n    }\n\n    return computedObservable;\n};\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n    if (entryToDispose !== null && entryToDispose.dispose) {\n        entryToDispose.dispose();\n    }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable, id) {\n    var computedObservable = this.computedObservable,\n        state = computedObservable[computedState];\n    if (!state.isDisposed) {\n        if (this.disposalCount && this.disposalCandidates[id]) {\n            // Don't want to dispose this subscription, as it's still being used\n            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);\n            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n            --this.disposalCount;\n        } else if (!state.dependencyTracking[id]) {\n            // Brand new subscription - add it\n            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));\n        }\n    }\n}\n\nvar computedFn = {\n    \"equalityComparer\": valuesArePrimitiveAndEqual,\n    getDependenciesCount: function () {\n        return this[computedState].dependenciesCount;\n    },\n    addDependencyTracking: function (id, target, trackingObj) {\n        if (this[computedState].pure && target === this) {\n            throw Error(\"A 'pure' computed must not be called recursively\");\n        }\n\n        this[computedState].dependencyTracking[id] = trackingObj;\n        trackingObj._order = this[computedState].dependenciesCount++;\n        trackingObj._version = target.getVersion();\n    },\n    haveDependenciesChanged: function () {\n        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;\n        for (id in dependencyTracking) {\n            if (dependencyTracking.hasOwnProperty(id)) {\n                dependency = dependencyTracking[id];\n                if (dependency._target.hasChanged(dependency._version)) {\n                    return true;\n                }\n            }\n        }\n    },\n    markDirty: function () {\n        // Process \"dirty\" events if we can handle delayed notifications\n        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n            this._evalDelayed();\n        }\n    },\n    isActive: function () {\n        return this[computedState].isStale || this[computedState].dependenciesCount > 0;\n    },\n    respondToChange: function () {\n        // Ignore \"change\" events if we've already scheduled a delayed notification\n        if (!this._notificationIsPending) {\n            this.evaluatePossiblyAsync();\n        }\n    },\n    subscribeToDependency: function (target) {\n        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {\n            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n                changeSub = target.subscribe(this.respondToChange, this);\n            return {\n                _target: target,\n                dispose: function () {\n                    dirtySub.dispose();\n                    changeSub.dispose();\n                }\n            };\n        } else {\n            return target.subscribe(this.evaluatePossiblyAsync, this);\n        }\n    },\n    evaluatePossiblyAsync: function () {\n        var computedObservable = this,\n            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];\n        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n            clearTimeout(this[computedState].evaluationTimeoutInstance);\n            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {\n                computedObservable.evaluateImmediate(true /*notifyChange*/);\n            }, throttleEvaluationTimeout);\n        } else if (computedObservable._evalDelayed) {\n            computedObservable._evalDelayed();\n        } else {\n            computedObservable.evaluateImmediate(true /*notifyChange*/);\n        }\n    },\n    evaluateImmediate: function (notifyChange) {\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            disposeWhen = state.disposeWhen;\n\n        if (state.isBeingEvaluated) {\n            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n            return;\n        }\n\n        // Do not evaluate (and possibly capture new dependencies) if disposed\n        if (state.isDisposed) {\n            return;\n        }\n\n        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {\n            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse\n            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {\n                computedObservable.dispose();\n                return;\n            }\n        } else {\n            // It just did return false, so we can stop suppressing now\n            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n        }\n\n        state.isBeingEvaluated = true;\n        try {\n            this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n        } finally {\n            state.isBeingEvaluated = false;\n        }\n\n        if (!state.dependenciesCount) {\n            computedObservable.dispose();\n        }\n    },\n    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {\n        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n        var computedObservable = this,\n            state = computedObservable[computedState];\n\n        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n        // Then, during evaluation, we cross off any that are in fact still being used.\n        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time\n            dependencyDetectionContext = {\n                computedObservable: computedObservable,\n                disposalCandidates: state.dependencyTracking,\n                disposalCount: state.dependenciesCount\n            };\n\n        ko.dependencyDetection.begin({\n            callbackTarget: dependencyDetectionContext,\n            callback: computedBeginDependencyDetectionCallback,\n            computed: computedObservable,\n            isInitial: isInitial\n        });\n\n        state.dependencyTracking = {};\n        state.dependenciesCount = 0;\n\n        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n        if (computedObservable.isDifferent(state.latestValue, newValue)) {\n            if (!state.isSleeping) {\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"beforeChange\");\n            }\n\n            state.latestValue = newValue;\n\n            if (state.isSleeping) {\n                computedObservable.updateVersion();\n            } else if (notifyChange) {\n                computedObservable[\"notifySubscribers\"](state.latestValue);\n            }\n        }\n\n        if (isInitial) {\n            computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n        }\n    },\n    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {\n        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n        // overhead of computed evaluation (on V8 at least).\n\n        try {\n            var readFunction = state.readFunction;\n            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n        } finally {\n            ko.dependencyDetection.end();\n\n            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n            }\n\n            state.isStale = false;\n        }\n    },\n    peek: function () {\n        // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n        var state = this[computedState];\n        if ((state.isStale && !state.dependenciesCount) || (state.isSleeping && this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return state.latestValue;\n    },\n    limit: function (limitFunction) {\n        // Override the limit function with one that delays evaluation as well\n        ko.subscribable['fn'].limit.call(this, limitFunction);\n        this._evalDelayed = function () {\n            this._limitBeforeChange(this[computedState].latestValue);\n\n            this[computedState].isStale = true; // Mark as dirty\n\n            // Pass the observable to the \"limit\" code, which will access it when\n            // it's time to do the notification.\n            this._limitChange(this);\n        }\n    },\n    dispose: function () {\n        var state = this[computedState];\n        if (!state.isSleeping && state.dependencyTracking) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose)\n                    dependency.dispose();\n            });\n        }\n        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {\n            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);\n        }\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isDisposed = true;\n        state.isStale = false;\n        state.isSleeping = false;\n        state.disposeWhenNodeIsRemoved = null;\n    }\n};\n\nvar pureComputedOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // If asleep, wake up the computed by subscribing to any dependencies.\n        var computedObservable = this,\n            state = computedObservable[computedState];\n        if (!state.isDisposed && state.isSleeping && event == 'change') {\n            state.isSleeping = false;\n            if (state.isStale || computedObservable.haveDependenciesChanged()) {\n                state.dependencyTracking = null;\n                state.dependenciesCount = 0;\n                state.isStale = true;\n                computedObservable.evaluateImmediate();\n            } else {\n                // First put the dependencies in order\n                var dependeciesOrder = [];\n                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                    dependeciesOrder[dependency._order] = id;\n                });\n                // Next, subscribe to each one\n                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {\n                    var dependency = state.dependencyTracking[id],\n                        subscription = computedObservable.subscribeToDependency(dependency._target);\n                    subscription._order = order;\n                    subscription._version = dependency._version;\n                    state.dependencyTracking[id] = subscription;\n                });\n            }\n            if (!state.isDisposed) {     // test since evaluating could trigger disposal\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n            }\n        }\n    },\n    afterSubscriptionRemove: function (event) {\n        var state = this[computedState];\n        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose) {\n                    state.dependencyTracking[id] = {\n                        _target: dependency._target,\n                        _order: dependency._order,\n                        _version: dependency._version\n                    };\n                    dependency.dispose();\n                }\n            });\n            state.isSleeping = true;\n            this[\"notifySubscribers\"](undefined, \"asleep\");\n        }\n    },\n    getVersion: function () {\n        // Because a pure computed is not automatically updated while it is sleeping, we can't\n        // simply return the version number. Instead, we check if any of the dependencies have\n        // changed and conditionally re-evaluate the computed observable.\n        var state = this[computedState];\n        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return ko.subscribable['fn'].getVersion.call(this);\n    }\n};\n\nvar deferEvaluationOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n        if (event == 'change' || event == 'beforeChange') {\n            this.peek();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = ko.observable.protoProperty; // == \"__ko_proto__\"\nko.computed[protoProp] = ko.observable;\ncomputedFn[protoProp] = ko.computed;\n\nko.isComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed);\n};\n\nko.isPureComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed)\n        && instance[computedState] && instance[computedState].pure;\n};\n\nko.exportSymbol('computed', ko.computed);\nko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)\nko.exportSymbol('isComputed', ko.isComputed);\nko.exportSymbol('isPureComputed', ko.isPureComputed);\nko.exportSymbol('computed.fn', computedFn);\nko.exportProperty(computedFn, 'peek', computedFn.peek);\nko.exportProperty(computedFn, 'dispose', computedFn.dispose);\nko.exportProperty(computedFn, 'isActive', computedFn.isActive);\nko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);\n\nko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n    if (typeof evaluatorFunctionOrOptions === 'function') {\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});\n    } else {\n        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object\n        evaluatorFunctionOrOptions['pure'] = true;\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n    }\n}\nko.exportSymbol('pureComputed', ko.pureComputed);\n"]}