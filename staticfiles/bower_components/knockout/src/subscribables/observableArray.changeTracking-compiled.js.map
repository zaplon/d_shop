{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/subscribables/observableArray.changeTracking.js"],"names":[],"mappings":"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","file":"observableArray.changeTracking-compiled.js","sourcesContent":["var arrayChangeEventName = 'arrayChange';\nko.extenders['trackArrayChanges'] = function(target, options) {\n    // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n    target.compareArrayOptions = {};\n    if (options && typeof options == \"object\") {\n        ko.utils.extend(target.compareArrayOptions, options);\n    }\n    target.compareArrayOptions['sparse'] = true;\n\n    // Only modify the target observable once\n    if (target.cacheDiffForKnownOperation) {\n        return;\n    }\n    var trackingChanges = false,\n        cachedDiff = null,\n        arrayChangeSubscription,\n        pendingNotifications = 0,\n        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n    // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n    target.beforeSubscriptionAdd = function (event) {\n        if (underlyingBeforeSubscriptionAddFunction)\n            underlyingBeforeSubscriptionAddFunction.call(target, event);\n        if (event === arrayChangeEventName) {\n            trackChanges();\n        }\n    };\n    // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n    target.afterSubscriptionRemove = function (event) {\n        if (underlyingAfterSubscriptionRemoveFunction)\n            underlyingAfterSubscriptionRemoveFunction.call(target, event);\n        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n            arrayChangeSubscription.dispose();\n            trackingChanges = false;\n        }\n    };\n\n    function trackChanges() {\n        // Calling 'trackChanges' multiple times is the same as calling it once\n        if (trackingChanges) {\n            return;\n        }\n\n        trackingChanges = true;\n\n        // Intercept \"notifySubscribers\" to track how many times it was called.\n        var underlyingNotifySubscribersFunction = target['notifySubscribers'];\n        target['notifySubscribers'] = function(valueToNotify, event) {\n            if (!event || event === defaultEvent) {\n                ++pendingNotifications;\n            }\n            return underlyingNotifySubscribersFunction.apply(this, arguments);\n        };\n\n        // Each time the array changes value, capture a clone so that on the next\n        // change it's possible to produce a diff\n        var previousContents = [].concat(target.peek() || []);\n        cachedDiff = null;\n        arrayChangeSubscription = target.subscribe(function(currentContents) {\n            // Make a copy of the current contents and ensure it's an array\n            currentContents = [].concat(currentContents || []);\n\n            // Compute the diff and issue notifications, but only if someone is listening\n            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n                var changes = getChanges(previousContents, currentContents);\n            }\n\n            // Eliminate references to the old, removed items, so they can be GCed\n            previousContents = currentContents;\n            cachedDiff = null;\n            pendingNotifications = 0;\n\n            if (changes && changes.length) {\n                target['notifySubscribers'](changes, arrayChangeEventName);\n            }\n        });\n    }\n\n    function getChanges(previousContents, currentContents) {\n        // We try to re-use cached diffs.\n        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n        // notifications are issued immediately so we wouldn't be queueing up more than one.\n        if (!cachedDiff || pendingNotifications > 1) {\n            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n        }\n\n        return cachedDiff;\n    }\n\n    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {\n        // Only run if we're currently tracking changes for this observable array\n        // and there aren't any pending deferred notifications.\n        if (!trackingChanges || pendingNotifications) {\n            return;\n        }\n        var diff = [],\n            arrayLength = rawArray.length,\n            argsLength = args.length,\n            offset = 0;\n\n        function pushDiff(status, value, index) {\n            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n        }\n        switch (operationName) {\n            case 'push':\n                offset = arrayLength;\n            case 'unshift':\n                for (var index = 0; index < argsLength; index++) {\n                    pushDiff('added', args[index], offset + index);\n                }\n                break;\n\n            case 'pop':\n                offset = arrayLength - 1;\n            case 'shift':\n                if (arrayLength) {\n                    pushDiff('deleted', rawArray[offset], offset);\n                }\n                break;\n\n            case 'splice':\n                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n                    endAddIndex = startIndex + argsLength - 2,\n                    endIndex = Math.max(endDeleteIndex, endAddIndex),\n                    additions = [], deletions = [];\n                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n                    if (index < endDeleteIndex)\n                        deletions.push(pushDiff('deleted', rawArray[index], index));\n                    if (index < endAddIndex)\n                        additions.push(pushDiff('added', args[argsIndex], index));\n                }\n                ko.utils.findMovesInArrayComparison(deletions, additions);\n                break;\n\n            default:\n                return;\n        }\n        cachedDiff = diff;\n    };\n};\n"]}