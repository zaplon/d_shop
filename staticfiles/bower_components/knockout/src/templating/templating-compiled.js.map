{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/templating/templating.js"],"names":[],"mappings":"AAAA,CAAC,YAAY;AACT,QAAI,eAAJ;AACA,OAAG,iBAAH,GAAuB,UAAU,cAAV,EAA0B;AAC7C,YAAK,kBAAkB,SAAnB,IAAiC,EAAE,0BAA0B,GAAG,cAA/B,CAArC,EACI,MAAM,IAAI,KAAJ,CAAU,oDAAV,CAAN;AACJ,0BAAkB,cAAlB;AACH,KAJD;;AAMA,aAAS,kCAAT,CAA4C,SAA5C,EAAuD,QAAvD,EAAiE,MAAjE,EAAyE;AACrE,YAAI,IAAJ;AAAA,YAAU,cAAc,SAAxB;AAAA,YAAmC,sBAAsB,GAAG,eAAH,CAAmB,WAAnB,CAA+B,QAA/B,CAAzD;AACA,eAAO,eAAgB,CAAC,OAAO,WAAR,MAAyB,mBAAhD,EAAsE;AAClE,0BAAc,GAAG,eAAH,CAAmB,WAAnB,CAA+B,IAA/B,CAAd;AACA,mBAAO,IAAP,EAAa,WAAb;AACH;AACJ;;AAED,aAAS,qCAAT,CAA+C,mBAA/C,EAAoE,cAApE,EAAoF;AAChF;AACA;AACA;AACA;AACA;;AAEA,YAAI,oBAAoB,MAAxB,EAAgC;AAC5B,gBAAI,YAAY,oBAAoB,CAApB,CAAhB;AAAA,gBACI,WAAW,oBAAoB,oBAAoB,MAApB,GAA6B,CAAjD,CADf;AAAA,gBAEI,aAAa,UAAU,UAF3B;AAAA,gBAGI,WAAW,GAAG,eAAH,CAAmB,UAAnB,CAHf;AAAA,gBAII,iBAAiB,SAAS,gBAAT,CAJrB;;AAMA,gBAAI,cAAJ,EAAoB;AAChB,mDAAmC,SAAnC,EAA8C,QAA9C,EAAwD,UAAS,IAAT,EAAe,eAAf,EAAgC;AACpF,wBAAI,sBAAsB,KAAK,eAA/B;AACA,wBAAI,WAAW,eAAe,IAAf,CAAoB,QAApB,EAA8B,IAA9B,CAAf;AACA,wBAAI,QAAJ,EAAc;AACV,4BAAI,SAAS,SAAb,EACI,YAAY,SAAS,CAAT,KAAe,eAA3B;AACJ,4BAAI,SAAS,QAAb,EACI,WAAW,SAAS,SAAS,MAAT,GAAkB,CAA3B,KAAiC,mBAA5C;AACP;AACJ,iBATD;;AAWA;AACA;AACA;AACA,oCAAoB,MAApB,GAA6B,CAA7B;AACA,oBAAI,CAAC,SAAL,EAAgB;AAAE;AACd;AACH;AACD,oBAAI,cAAc,QAAlB,EAA4B;AACxB,wCAAoB,IAApB,CAAyB,SAAzB;AACH,iBAFD,MAEO;AACH,wCAAoB,IAApB,CAAyB,SAAzB,EAAoC,QAApC;AACA,uBAAG,KAAH,CAAS,wBAAT,CAAkC,mBAAlC,EAAuD,UAAvD;AACH;AACJ;;AAED;AACA;AACA,+CAAmC,SAAnC,EAA8C,QAA9C,EAAwD,UAAS,IAAT,EAAe;AACnE,oBAAI,KAAK,QAAL,KAAkB,CAAlB,IAAuB,KAAK,QAAL,KAAkB,CAA7C,EACI,GAAG,aAAH,CAAiB,cAAjB,EAAiC,IAAjC;AACP,aAHD;AAIA,+CAAmC,SAAnC,EAA8C,QAA9C,EAAwD,UAAS,IAAT,EAAe;AACnE,oBAAI,KAAK,QAAL,KAAkB,CAAlB,IAAuB,KAAK,QAAL,KAAkB,CAA7C,EACI,GAAG,WAAH,CAAe,8BAAf,CAA8C,IAA9C,EAAoD,CAAC,cAAD,CAApD;AACP,aAHD;;AAKA;AACA,eAAG,KAAH,CAAS,wBAAT,CAAkC,mBAAlC,EAAuD,UAAvD;AACH;AACJ;;AAED,aAAS,6BAAT,CAAuC,eAAvC,EAAwD;AACpD,eAAO,gBAAgB,QAAhB,GAA2B,eAA3B,GAC2B,gBAAgB,MAAhB,GAAyB,CAAzB,GAA6B,gBAAgB,CAAhB,CAA7B,GACA,IAFlC;AAGH;;AAED,aAAS,eAAT,CAAyB,qBAAzB,EAAgD,UAAhD,EAA4D,QAA5D,EAAsE,cAAtE,EAAsF,OAAtF,EAA+F;AAC3F,kBAAU,WAAW,EAArB;AACA,YAAI,kBAAkB,yBAAyB,8BAA8B,qBAA9B,CAA/C;AACA,YAAI,mBAAmB,CAAC,mBAAmB,QAAnB,IAA+B,EAAhC,EAAoC,aAA3D;AACA,YAAI,sBAAuB,QAAQ,gBAAR,KAA6B,eAAxD;AACA,WAAG,iBAAH,CAAqB,yBAArB,CAA+C,QAA/C,EAAyD,mBAAzD,EAA8E,gBAA9E;AACA,YAAI,qBAAqB,oBAAoB,gBAApB,EAAsC,QAAtC,EAAgD,cAAhD,EAAgE,OAAhE,EAAyE,gBAAzE,CAAzB;;AAEA;AACA,YAAK,OAAO,mBAAmB,MAA1B,IAAoC,QAArC,IAAmD,mBAAmB,MAAnB,GAA4B,CAA5B,IAAiC,OAAO,mBAAmB,CAAnB,EAAsB,QAA7B,IAAyC,QAAjI,EACI,MAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;;AAEJ,YAAI,yBAAyB,KAA7B;AACA,gBAAQ,UAAR;AACI,iBAAK,iBAAL;AACI,mBAAG,eAAH,CAAmB,kBAAnB,CAAsC,qBAAtC,EAA6D,kBAA7D;AACA,yCAAyB,IAAzB;AACA;AACJ,iBAAK,aAAL;AACI,mBAAG,KAAH,CAAS,eAAT,CAAyB,qBAAzB,EAAgD,kBAAhD;AACA,yCAAyB,IAAzB;AACA;AACJ,iBAAK,kBAAL;AAAyB;AACzB;AACI,sBAAM,IAAI,KAAJ,CAAU,yBAAyB,UAAnC,CAAN;AAXR;;AAcA,YAAI,sBAAJ,EAA4B;AACxB,kDAAsC,kBAAtC,EAA0D,cAA1D;AACA,gBAAI,QAAQ,aAAR,CAAJ,EACI,GAAG,mBAAH,CAAuB,MAAvB,CAA8B,QAAQ,aAAR,CAA9B,EAAsD,IAAtD,EAA4D,CAAC,kBAAD,EAAqB,eAAe,OAAf,CAArB,CAA5D;AACP;;AAED,eAAO,kBAAP;AACH;;AAED,aAAS,mBAAT,CAA6B,QAA7B,EAAuC,IAAvC,EAA6C,OAA7C,EAAsD;AAClD;AACA,YAAI,GAAG,YAAH,CAAgB,QAAhB,CAAJ,EAA+B;AAC3B;AACA,mBAAO,UAAP;AACH,SAHD,MAGO,IAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AACvC;AACA,mBAAO,SAAS,IAAT,EAAe,OAAf,CAAP;AACH,SAHM,MAGA;AACH;AACA,mBAAO,QAAP;AACH;AACJ;;AAED,OAAG,cAAH,GAAoB,UAAU,QAAV,EAAoB,oBAApB,EAA0C,OAA1C,EAAmD,qBAAnD,EAA0E,UAA1E,EAAsF;AACtG,kBAAU,WAAW,EAArB;AACA,YAAI,CAAC,QAAQ,gBAAR,KAA6B,eAA9B,KAAkD,SAAtD,EACI,MAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN;AACJ,qBAAa,cAAc,iBAA3B;;AAEA,YAAI,qBAAJ,EAA2B;AACvB,gBAAI,kBAAkB,8BAA8B,qBAA9B,CAAtB;;AAEA,gBAAI,gBAAgB,YAAY;AAAE,uBAAQ,CAAC,eAAF,IAAsB,CAAC,GAAG,KAAH,CAAS,2BAAT,CAAqC,eAArC,CAA9B;AAAsF,aAAxH,CAA0H;AAC1H,gBAAI,mCAAoC,mBAAmB,cAAc,aAAlC,GAAmD,gBAAgB,UAAnE,GAAgF,eAAvH;;AAEA,mBAAO,GAAG,mBAAH,CAAwB;AAC3B,wBAAY;AACR;AACA,oBAAI,iBAAkB,wBAAyB,gCAAgC,GAAG,cAA7D,GACf,oBADe,GAEf,IAAI,GAAG,cAAP,CAAsB,GAAG,KAAH,CAAS,gBAAT,CAA0B,oBAA1B,CAAtB,CAFN;;AAIA,oBAAI,eAAe,oBAAoB,QAApB,EAA8B,eAAe,OAAf,CAA9B,EAAuD,cAAvD,CAAnB;AAAA,oBACI,qBAAqB,gBAAgB,qBAAhB,EAAuC,UAAvC,EAAmD,YAAnD,EAAiE,cAAjE,EAAiF,OAAjF,CADzB;;AAGA,oBAAI,cAAc,aAAlB,EAAiC;AAC7B,4CAAwB,kBAAxB;AACA,sCAAkB,8BAA8B,qBAA9B,CAAlB;AACH;AACJ,aAdE,EAeH,IAfG,EAgBH,EAAE,aAAa,aAAf,EAA8B,0BAA0B,gCAAxD,EAhBG,CAAP;AAkBH,SAxBD,MAwBO;AACH;AACA,mBAAO,GAAG,WAAH,CAAe,OAAf,CAAuB,UAAU,OAAV,EAAmB;AAC7C,mBAAG,cAAH,CAAkB,QAAlB,EAA4B,oBAA5B,EAAkD,OAAlD,EAA2D,OAA3D,EAAoE,aAApE;AACH,aAFM,CAAP;AAGH;AACJ,KApCD;;AAsCA,OAAG,qBAAH,GAA2B,UAAU,QAAV,EAAoB,sBAApB,EAA4C,OAA5C,EAAqD,UAArD,EAAiE,oBAAjE,EAAuF;AAC9G;AACA;AACA,YAAI,gBAAJ;;AAEA;AACA,YAAI,8BAA8B,UAAU,UAAV,EAAsB,KAAtB,EAA6B;AAC3D;AACA,+BAAmB,qBAAqB,oBAArB,EAA2C,UAA3C,EAAuD,QAAQ,IAAR,CAAvD,EAAsE,UAAS,OAAT,EAAkB;AACvG,wBAAQ,QAAR,IAAoB,KAApB;AACH,aAFkB,CAAnB;;AAIA,gBAAI,eAAe,oBAAoB,QAApB,EAA8B,UAA9B,EAA0C,gBAA1C,CAAnB;AACA,mBAAO,gBAAgB,IAAhB,EAAsB,kBAAtB,EAA0C,YAA1C,EAAwD,gBAAxD,EAA0E,OAA1E,CAAP;AACH,SARD;;AAUA;AACA,YAAI,2BAA2B,UAAS,UAAT,EAAqB,eAArB,EAAsC,KAAtC,EAA6C;AACxE,kDAAsC,eAAtC,EAAuD,gBAAvD;AACA,gBAAI,QAAQ,aAAR,CAAJ,EACI,QAAQ,aAAR,EAAuB,eAAvB,EAAwC,UAAxC;;AAEJ;AACA;AACA,+BAAmB,IAAnB;AACH,SARD;;AAUA,eAAO,GAAG,mBAAH,CAAuB,YAAY;AACtC,gBAAI,iBAAiB,GAAG,KAAH,CAAS,gBAAT,CAA0B,sBAA1B,KAAqD,EAA1E;AACA,gBAAI,OAAO,eAAe,MAAtB,IAAgC,WAApC,EAAiD;AAC7C,iCAAiB,CAAC,cAAD,CAAjB;;AAEJ;AACA,gBAAI,gBAAgB,GAAG,KAAH,CAAS,WAAT,CAAqB,cAArB,EAAqC,UAAS,IAAT,EAAe;AACpE,uBAAO,QAAQ,kBAAR,KAA+B,SAAS,SAAxC,IAAqD,SAAS,IAA9D,IAAsE,CAAC,GAAG,KAAH,CAAS,gBAAT,CAA0B,KAAK,UAAL,CAA1B,CAA9E;AACH,aAFmB,CAApB;;AAIA;AACA;AACA,eAAG,mBAAH,CAAuB,MAAvB,CAA8B,GAAG,KAAH,CAAS,kCAAvC,EAA2E,IAA3E,EAAiF,CAAC,UAAD,EAAa,aAAb,EAA4B,2BAA5B,EAAyD,OAAzD,EAAkE,wBAAlE,CAAjF;AAEH,SAdM,EAcJ,IAdI,EAcE,EAAE,0BAA0B,UAA5B,EAdF,CAAP;AAeH,KA1CD;;AA4CA,QAAI,6BAA6B,GAAG,KAAH,CAAS,OAAT,CAAiB,OAAjB,EAAjC;AACA,aAAS,gCAAT,CAA0C,OAA1C,EAAmD,WAAnD,EAAgE;AAC5D,YAAI,cAAc,GAAG,KAAH,CAAS,OAAT,CAAiB,GAAjB,CAAqB,OAArB,EAA8B,0BAA9B,CAAlB;AACA,YAAI,eAAgB,OAAO,YAAY,OAAnB,IAA+B,UAAnD,EACI,YAAY,OAAZ;AACJ,WAAG,KAAH,CAAS,OAAT,CAAiB,GAAjB,CAAqB,OAArB,EAA8B,0BAA9B,EAA2D,eAAe,YAAY,QAAZ,EAAhB,GAA0C,WAA1C,GAAwD,SAAlH;AACH;;AAED,OAAG,eAAH,CAAmB,UAAnB,IAAiC;AAC7B,gBAAQ,UAAS,OAAT,EAAkB,aAAlB,EAAiC;AACrC;AACA,gBAAI,eAAe,GAAG,KAAH,CAAS,gBAAT,CAA0B,eAA1B,CAAnB;AACA,gBAAI,OAAO,YAAP,IAAuB,QAAvB,IAAmC,aAAa,MAAb,CAAvC,EAA6D;AACzD;AACA,mBAAG,eAAH,CAAmB,SAAnB,CAA6B,OAA7B;AACH,aAHD,MAGO,IAAI,WAAW,YAAf,EAA6B;AAChC;AACA;AACA;AACA;AACA,oBAAI,QAAQ,aAAa,OAAb,KAAyB,EAArC;AACA,oBAAI,GAAG,YAAH,CAAgB,KAAhB,CAAJ,EAA4B;AACxB,0BAAM,IAAI,KAAJ,CAAU,2DAAV,CAAN;AACH;AACD,oBAAI,YAAY,GAAG,KAAH,CAAS,kCAAT,CAA4C,KAA5C,CAAhB,CAAoE;AACpE,oBAAI,GAAG,eAAH,CAAmB,iBAAvB,CAAyC,OAAzC,EAAkD,OAAlD,EAA2D,SAA3D;AACH,aAXM,MAWA;AACH;AACA,oBAAI,gBAAgB,GAAG,eAAH,CAAmB,UAAnB,CAA8B,OAA9B,CAApB;AAAA,oBACI,YAAY,GAAG,KAAH,CAAS,kCAAT,CAA4C,aAA5C,CADhB,CAC4E;AAC5E,oBAAI,GAAG,eAAH,CAAmB,iBAAvB,CAAyC,OAAzC,EAAkD,OAAlD,EAA2D,SAA3D;AACH;AACD,mBAAO,EAAE,8BAA8B,IAAhC,EAAP;AACH,SAzB4B;AA0B7B,kBAAU,UAAU,OAAV,EAAmB,aAAnB,EAAkC,WAAlC,EAA+C,SAA/C,EAA0D,cAA1D,EAA0E;AAChF,gBAAI,QAAQ,eAAZ;AAAA,gBACI,SADJ;AAAA,gBAEI,UAAU,GAAG,KAAH,CAAS,gBAAT,CAA0B,KAA1B,CAFd;AAAA,gBAGI,gBAAgB,IAHpB;AAAA,gBAII,mBAAmB,IAJvB;AAAA,gBAKI,YALJ;;AAOA,gBAAI,OAAO,OAAP,IAAkB,QAAtB,EAAgC;AAC5B,+BAAe,KAAf;AACA,0BAAU,EAAV;AACH,aAHD,MAGO;AACH,+BAAe,QAAQ,MAAR,CAAf;;AAEA;AACA,oBAAI,QAAQ,OAAZ,EACI,gBAAgB,GAAG,KAAH,CAAS,gBAAT,CAA0B,QAAQ,IAAR,CAA1B,CAAhB;AACJ,oBAAI,iBAAiB,WAAW,OAAhC,EACI,gBAAgB,CAAC,GAAG,KAAH,CAAS,gBAAT,CAA0B,QAAQ,OAAR,CAA1B,CAAjB;;AAEJ,4BAAY,GAAG,KAAH,CAAS,gBAAT,CAA0B,QAAQ,MAAR,CAA1B,CAAZ;AACH;;AAED,gBAAI,aAAa,OAAjB,EAA0B;AACtB;AACA,oBAAI,YAAa,iBAAiB,QAAQ,SAAR,CAAlB,IAAyC,EAAzD;AACA,mCAAmB,GAAG,qBAAH,CAAyB,gBAAgB,OAAzC,EAAkD,SAAlD,EAA6D,OAA7D,EAAsE,OAAtE,EAA+E,cAA/E,CAAnB;AACH,aAJD,MAIO,IAAI,CAAC,aAAL,EAAoB;AACvB,mBAAG,eAAH,CAAmB,SAAnB,CAA6B,OAA7B;AACH,aAFM,MAEA;AACH;AACA,oBAAI,sBAAuB,UAAU,OAAX,GACtB,eAAe,oBAAf,EAAqC,SAArC,EAAgD,QAAQ,IAAR,CAAhD,CADsB,GAC4C;AAClE,8BAFJ,CAE2E;AAC3E,mCAAmB,GAAG,cAAH,CAAkB,gBAAgB,OAAlC,EAA2C,mBAA3C,EAAgE,OAAhE,EAAyE,OAAzE,CAAnB;AACH;;AAED;AACA,6CAAiC,OAAjC,EAA0C,gBAA1C;AACH;AAjE4B,KAAjC;;AAoEA;AACA,OAAG,mBAAH,CAAuB,wBAAvB,CAAgD,UAAhD,IAA8D,UAAS,YAAT,EAAuB;AACjF,YAAI,qBAAqB,GAAG,mBAAH,CAAuB,kBAAvB,CAA0C,YAA1C,CAAzB;;AAEA,YAAK,mBAAmB,MAAnB,IAA6B,CAA9B,IAAoC,mBAAmB,CAAnB,EAAsB,SAAtB,CAAxC,EACI,OAAO,IAAP,CAAa;;AAEjB,YAAI,GAAG,mBAAH,CAAuB,wBAAvB,CAAgD,kBAAhD,EAAoE,MAApE,CAAJ,EACI,OAAO,IAAP,CAAa;AACjB,eAAO,uFAAP;AACH,KATD;;AAWA,OAAG,eAAH,CAAmB,eAAnB,CAAmC,UAAnC,IAAiD,IAAjD;AACH,CA5SD;;AA8SA,GAAG,YAAH,CAAgB,mBAAhB,EAAqC,GAAG,iBAAxC;AACA,GAAG,YAAH,CAAgB,gBAAhB,EAAkC,GAAG,cAArC","file":"templating-compiled.js","sourcesContent":["(function () {\n    var _templateEngine;\n    ko.setTemplateEngine = function (templateEngine) {\n        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))\n            throw new Error(\"templateEngine must inherit from ko.templateEngine\");\n        _templateEngine = templateEngine;\n    }\n\n    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {\n        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);\n        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n            nextInQueue = ko.virtualElements.nextSibling(node);\n            action(node, nextInQueue);\n        }\n    }\n\n    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {\n        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n        // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n        if (continuousNodeArray.length) {\n            var firstNode = continuousNodeArray[0],\n                lastNode = continuousNodeArray[continuousNodeArray.length - 1],\n                parentNode = firstNode.parentNode,\n                provider = ko.bindingProvider['instance'],\n                preprocessNode = provider['preprocessNode'];\n\n            if (preprocessNode) {\n                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {\n                    var nodePreviousSibling = node.previousSibling;\n                    var newNodes = preprocessNode.call(provider, node);\n                    if (newNodes) {\n                        if (node === firstNode)\n                            firstNode = newNodes[0] || nextNodeInRange;\n                        if (node === lastNode)\n                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;\n                    }\n                });\n\n                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.\n                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real\n                // first node needs to be in the array).\n                continuousNodeArray.length = 0;\n                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do\n                    return;\n                }\n                if (firstNode === lastNode) {\n                    continuousNodeArray.push(firstNode);\n                } else {\n                    continuousNodeArray.push(firstNode, lastNode);\n                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n                }\n            }\n\n            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n            // whereas a regular applyBindings won't introduce new memoized nodes\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.applyBindings(bindingContext, node);\n            });\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);\n            });\n\n            // Make sure any changes done by applyBindings or unmemoize are reflected in the array\n            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n        }\n    }\n\n    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {\n        return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                        : null;\n    }\n\n    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {\n        options = options || {};\n        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n        var templateDocument = (firstTargetNode || template || {}).ownerDocument;\n        var templateEngineToUse = (options['templateEngine'] || _templateEngine);\n        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);\n        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);\n\n        // Loosely check result is an array of DOM nodes\n        if ((typeof renderedNodesArray.length != \"number\") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != \"number\"))\n            throw new Error(\"Template engine must return an array of DOM nodes\");\n\n        var haveAddedNodesToParent = false;\n        switch (renderMode) {\n            case \"replaceChildren\":\n                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"replaceNode\":\n                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"ignoreTargetNode\": break;\n            default:\n                throw new Error(\"Unknown renderMode: \" + renderMode);\n        }\n\n        if (haveAddedNodesToParent) {\n            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);\n            if (options['afterRender'])\n                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);\n        }\n\n        return renderedNodesArray;\n    }\n\n    function resolveTemplateName(template, data, context) {\n        // The template can be specified as:\n        if (ko.isObservable(template)) {\n            // 1. An observable, with string value\n            return template();\n        } else if (typeof template === 'function') {\n            // 2. A function of (data, context) returning a string\n            return template(data, context);\n        } else {\n            // 3. A string\n            return template;\n        }\n    }\n\n    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {\n        options = options || {};\n        if ((options['templateEngine'] || _templateEngine) == undefined)\n            throw new Error(\"Set a template engine before calling renderTemplate\");\n        renderMode = renderMode || \"replaceChildren\";\n\n        if (targetNodeOrNodeArray) {\n            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)\n            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == \"replaceNode\") ? firstTargetNode.parentNode : firstTargetNode;\n\n            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes\n                function () {\n                    // Ensure we've got a proper binding context to work with\n                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))\n                        ? dataOrBindingContext\n                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));\n\n                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),\n                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n\n                    if (renderMode == \"replaceNode\") {\n                        targetNodeOrNodeArray = renderedNodesArray;\n                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n                    }\n                },\n                null,\n                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }\n            );\n        } else {\n            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n            return ko.memoization.memoize(function (domNode) {\n                ko.renderTemplate(template, dataOrBindingContext, options, domNode, \"replaceNode\");\n            });\n        }\n    };\n\n    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {\n        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n        var arrayItemContext;\n\n        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n        var executeTemplateForArrayItem = function (arrayValue, index) {\n            // Support selecting template as a function of the data being rendered\n            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {\n                context['$index'] = index;\n            });\n\n            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);\n            return executeTemplate(null, \"ignoreTargetNode\", templateName, arrayItemContext, options);\n        }\n\n        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {\n            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);\n            if (options['afterRender'])\n                options['afterRender'](addedNodesArray, arrayValue);\n\n            // release the \"cache\" variable, so that it can be collected by\n            // the GC when its value isn't used from within the bindings anymore.\n            arrayItemContext = null;\n        };\n\n        return ko.dependentObservable(function () {\n            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).\n            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.\n            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);\n\n        }, null, { disposeWhenNodeIsRemoved: targetNode });\n    };\n\n    var templateComputedDomDataKey = ko.utils.domData.nextKey();\n    function disposeOldComputedAndStoreNewOne(element, newComputed) {\n        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);\n        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))\n            oldComputed.dispose();\n        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);\n    }\n\n    ko.bindingHandlers['template'] = {\n        'init': function(element, valueAccessor) {\n            // Support anonymous templates\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            if (typeof bindingValue == \"string\" || bindingValue['name']) {\n                // It's a named template - clear the element\n                ko.virtualElements.emptyNode(element);\n            } else if ('nodes' in bindingValue) {\n                // We've been given an array of DOM nodes. Save them as the template source.\n                // There is no known use case for the node array being an observable array (if the output\n                // varies, put that behavior *into* your template - that's what templates are for), and\n                // the implementation would be a mess, so assert that it's not observable.\n                var nodes = bindingValue['nodes'] || [];\n                if (ko.isObservable(nodes)) {\n                    throw new Error('The \"nodes\" option must be a plain, non-observable array.');\n                }\n                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            } else {\n                // It's an anonymous template - store the element contents, then clear the element\n                var templateNodes = ko.virtualElements.childNodes(element),\n                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            }\n            return { 'controlsDescendantBindings': true };\n        },\n        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var value = valueAccessor(),\n                dataValue,\n                options = ko.utils.unwrapObservable(value),\n                shouldDisplay = true,\n                templateComputed = null,\n                templateName;\n\n            if (typeof options == \"string\") {\n                templateName = value;\n                options = {};\n            } else {\n                templateName = options['name'];\n\n                // Support \"if\"/\"ifnot\" conditions\n                if ('if' in options)\n                    shouldDisplay = ko.utils.unwrapObservable(options['if']);\n                if (shouldDisplay && 'ifnot' in options)\n                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);\n\n                dataValue = ko.utils.unwrapObservable(options['data']);\n            }\n\n            if ('foreach' in options) {\n                // Render once for each data point (treating data set as empty if shouldDisplay==false)\n                var dataArray = (shouldDisplay && options['foreach']) || [];\n                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);\n            } else if (!shouldDisplay) {\n                ko.virtualElements.emptyNode(element);\n            } else {\n                // Render once for this single data point (or use the viewModel if no data was provided)\n                var innerBindingContext = ('data' in options) ?\n                    bindingContext['createChildContext'](dataValue, options['as']) :  // Given an explitit 'data' value, we create a child binding context for it\n                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context\n                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);\n            }\n\n            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)\n            disposeOldComputedAndStoreNewOne(element, templateComputed);\n        }\n    };\n\n    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.\n    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {\n        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);\n\n        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])\n            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)\n\n        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, \"name\"))\n            return null; // Named templates can be rewritten, so return \"no error\"\n        return \"This template engine does not support anonymous templates nested within its templates\";\n    };\n\n    ko.virtualElements.allowedBindings['template'] = true;\n})();\n\nko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);\nko.exportSymbol('renderTemplate', ko.renderTemplate);\n"]}