{"version":3,"sources":["../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/utils.domManipulation.js"],"names":[],"mappings":"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","file":"utils.domManipulation-compiled.js","sourcesContent":["(function () {\n    var none = [0, \"\", \"\"],\n        table = [1, \"<table>\", \"</table>\"],\n        tbody = [2, \"<table><tbody>\", \"</tbody></table>\"],\n        tr = [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        select = [1, \"<select multiple='multiple'>\", \"</select>\"],\n        lookup = {\n            'thead': table,\n            'tbody': table,\n            'tfoot': table,\n            'tr': tbody,\n            'td': tr,\n            'th': tr,\n            'option': select,\n            'optgroup': select\n        },\n\n        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.\n        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;\n\n    function getWrap(tags) {\n        var m = tags.match(/^<([a-z]+)[ >]/);\n        return (m && lookup[m[1]]) || none;\n    }\n\n    function simpleHtmlParse(html, documentContext) {\n        documentContext || (documentContext = document);\n        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;\n\n        // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n        // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n        // Trim whitespace, otherwise indexOf won't work as expected\n        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement(\"div\"),\n            wrap = getWrap(tags),\n            depth = wrap[0];\n\n        // Go to html and back, then peel off extra wrappers\n        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n        var markup = \"ignored<div>\" + wrap[1] + html + wrap[2] + \"</div>\";\n        if (typeof windowContext['innerShiv'] == \"function\") {\n            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding\n            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv\n            // somehow shims the native APIs so it just works anyway)\n            div.appendChild(windowContext['innerShiv'](markup));\n        } else {\n            if (mayRequireCreateElementHack) {\n                // The document.createElement('my-element') trick to enable custom elements in IE6-8\n                // only works if we assign innerHTML on an element associated with that document.\n                documentContext.appendChild(div);\n            }\n\n            div.innerHTML = markup;\n\n            if (mayRequireCreateElementHack) {\n                div.parentNode.removeChild(div);\n            }\n        }\n\n        // Move to the right depth\n        while (depth--)\n            div = div.lastChild;\n\n        return ko.utils.makeArray(div.lastChild.childNodes);\n    }\n\n    function jQueryHtmlParse(html, documentContext) {\n        // jQuery's \"parseHTML\" function was introduced in jQuery 1.8.0 and is a documented public API.\n        if (jQueryInstance['parseHTML']) {\n            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null\n        } else {\n            // For jQuery < 1.8.0, we fall back on the undocumented internal \"clean\" function.\n            var elems = jQueryInstance['clean']([html], documentContext);\n\n            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n            if (elems && elems[0]) {\n                // Find the top-most parent element that's a direct child of a document fragment\n                var elem = elems[0];\n                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)\n                    elem = elem.parentNode;\n                // ... then detach it\n                if (elem.parentNode)\n                    elem.parentNode.removeChild(elem);\n            }\n\n            return elems;\n        }\n    }\n\n    ko.utils.parseHtmlFragment = function(html, documentContext) {\n        return jQueryInstance ?\n            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible\n            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.\n    };\n\n    ko.utils.setHtml = function(node, html) {\n        ko.utils.emptyDomNode(node);\n\n        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it\n        html = ko.utils.unwrapObservable(html);\n\n        if ((html !== null) && (html !== undefined)) {\n            if (typeof html != 'string')\n                html = html.toString();\n\n            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n            // for example <tr> elements which are not normally allowed to exist on their own.\n            // If you've referenced jQuery we'll use that rather than duplicating its code.\n            if (jQueryInstance) {\n                jQueryInstance(node)['html'](html);\n            } else {\n                // ... otherwise, use KO's own parsing logic.\n                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);\n                for (var i = 0; i < parsedNodes.length; i++)\n                    node.appendChild(parsedNodes[i]);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);\nko.exportSymbol('utils.setHtml', ko.utils.setHtml);\n"]}