{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/binding/expressionRewriting.js"],"names":[],"mappings":"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","file":"expressionRewriting-compiled.js","sourcesContent":["ko.expressionRewriting = (function () {\n    var javaScriptReservedWords = [\"true\", \"false\", \"null\", \"undefined\"];\n\n    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor\n    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).\n    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).\n    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i;\n\n    function getWriteableValue(expression) {\n        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)\n            return false;\n        var match = expression.match(javaScriptAssignmentTarget);\n        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;\n    }\n\n    // The following regular expressions will be used to split an object-literal string into tokens\n\n        // These two match strings, either with double quotes or single quotes\n    var stringDouble = '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"',\n        stringSingle = \"'(?:[^'\\\\\\\\]|\\\\\\\\.)*'\",\n        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions\n        // as a regular expression (this is handled by the parsing loop below).\n        stringRegexp = '/(?:[^/\\\\\\\\]|\\\\\\\\.)*/\\w*',\n        // These characters have special meaning to the parser and must not appear in the middle of a\n        // token, except as part of a string.\n        specials = ',\"\\'{}()/:[\\\\]',\n        // Match text (at least two characters) that does not contain any of the above special characters,\n        // although some of the special characters are allowed to start it (all but the colon and comma).\n        // The text can contain spaces, but leading or trailing spaces are skipped.\n        everyThingElse = '[^\\\\s:,/][^' + specials + ']*[^\\\\s' + specials + ']',\n        // Match any non-space character not matched already. This will match colons and commas, since they're\n        // not matched by \"everyThingElse\", but will also match any other single character that wasn't already\n        // matched (for example: in \"a: 1, b: 2\", each of the non-space characters will be matched by oneNotSpace).\n        oneNotSpace = '[^\\\\s]',\n\n        // Create the actual regular expression by or-ing the above strings. The order is important.\n        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),\n\n        // Match end of previous token to determine whether a slash is a division or regex.\n        divisionLookBehind = /[\\])\"'A-Za-z0-9_$]+$/,\n        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};\n\n    function parseObjectLiteral(objectLiteralString) {\n        // Trim leading and trailing spaces from the string\n        var str = ko.utils.stringTrim(objectLiteralString);\n\n        // Trim braces '{' surrounding the whole object literal\n        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);\n\n        // Split into tokens\n        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;\n\n        if (toks) {\n            // Append a comma so that we don't need a separate code block to deal with the last item\n            toks.push(',');\n\n            for (var i = 0, tok; tok = toks[i]; ++i) {\n                var c = tok.charCodeAt(0);\n                // A comma signals the end of a key/value pair if depth is zero\n                if (c === 44) { // \",\"\n                    if (depth <= 0) {\n                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});\n                        key = depth = 0;\n                        values = [];\n                        continue;\n                    }\n                // Simply skip the colon that separates the name and value\n                } else if (c === 58) { // \":\"\n                    if (!depth && !key && values.length === 1) {\n                        key = values.pop();\n                        continue;\n                    }\n                // A set of slashes is initially matched as a regular expression, but could be division\n                } else if (c === 47 && i && tok.length > 1) {  // \"/\"\n                    // Look at the end of the previous token to determine if the slash is actually division\n                    var match = toks[i-1].match(divisionLookBehind);\n                    if (match && !keywordRegexLookBehind[match[0]]) {\n                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)\n                        str = str.substr(str.indexOf(tok) + 1);\n                        toks = str.match(bindingToken);\n                        toks.push(',');\n                        i = -1;\n                        // Continue with just the slash\n                        tok = '/';\n                    }\n                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored\n                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['\n                    ++depth;\n                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'\n                    --depth;\n                // The key will be the first token; if it's a string, trim the quotes\n                } else if (!key && !values.length && (c === 34 || c === 39)) { // '\"', \"'\"\n                    tok = tok.slice(1, -1);\n                }\n                values.push(tok);\n            }\n        }\n        return result;\n    }\n\n    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.\n    var twoWayBindings = {};\n\n    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {\n        bindingOptions = bindingOptions || {};\n\n        function processKeyValue(key, val) {\n            var writableVal;\n            function callPreprocessHook(obj) {\n                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;\n            }\n            if (!bindingParams) {\n                if (!callPreprocessHook(ko['getBindingHandler'](key)))\n                    return;\n\n                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {\n                    // For two-way bindings, provide a write method in case the value\n                    // isn't a writable observable.\n                    propertyAccessorResultStrings.push(\"'\" + key + \"':function(_z){\" + writableVal + \"=_z}\");\n                }\n            }\n            // Values are wrapped in a function so that each value can be accessed independently\n            if (makeValueAccessors) {\n                val = 'function(){return ' + val + ' }';\n            }\n            resultStrings.push(\"'\" + key + \"':\" + val);\n        }\n\n        var resultStrings = [],\n            propertyAccessorResultStrings = [],\n            makeValueAccessors = bindingOptions['valueAccessors'],\n            bindingParams = bindingOptions['bindingParams'],\n            keyValueArray = typeof bindingsStringOrKeyValueArray === \"string\" ?\n                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;\n\n        ko.utils.arrayForEach(keyValueArray, function(keyValue) {\n            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);\n        });\n\n        if (propertyAccessorResultStrings.length)\n            processKeyValue('_ko_property_writers', \"{\" + propertyAccessorResultStrings.join(\",\") + \" }\");\n\n        return resultStrings.join(\",\");\n    }\n\n    return {\n        bindingRewriteValidators: [],\n\n        twoWayBindings: twoWayBindings,\n\n        parseObjectLiteral: parseObjectLiteral,\n\n        preProcessBindings: preProcessBindings,\n\n        keyValueArrayContainsKey: function(keyValueArray, key) {\n            for (var i = 0; i < keyValueArray.length; i++)\n                if (keyValueArray[i]['key'] == key)\n                    return true;\n            return false;\n        },\n\n        // Internal, private KO utility for updating model properties from within bindings\n        // property:            If the property being updated is (or might be) an observable, pass it here\n        //                      If it turns out to be a writable observable, it will be written to directly\n        // allBindings:         An object with a get method to retrieve bindings in the current execution context.\n        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable\n        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'\n        // value:               The value to be written\n        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if\n        //                      it is !== existing value on that writable observable\n        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {\n            if (!property || !ko.isObservable(property)) {\n                var propWriters = allBindings.get('_ko_property_writers');\n                if (propWriters && propWriters[key])\n                    propWriters[key](value);\n            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {\n                property(value);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('expressionRewriting', ko.expressionRewriting);\nko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);\nko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);\nko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);\n\n// Making bindings explicitly declare themselves as \"two way\" isn't ideal in the long term (it would be better if\n// all bindings could use an official 'property writer' API without needing to declare that they might). However,\n// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable\n// as an internal implementation detail in the short term.\n// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an\n// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official\n// public API, and we reserve the right to remove it at any time if we create a real public property writers API.\nko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);\n\n// For backward compatibility, define the following aliases. (Previously, these function names were misleading because\n// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)\nko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);\nko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);\n"]}