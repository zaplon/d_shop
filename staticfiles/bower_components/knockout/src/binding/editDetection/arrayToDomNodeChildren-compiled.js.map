{"version":3,"sources":["../../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/binding/editDetection/arrayToDomNodeChildren.js"],"names":[],"mappings":"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","file":"arrayToDomNodeChildren-compiled.js","sourcesContent":["(function () {\n    // Objective:\n    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n    //   previously mapped - retain those nodes, and just insert/delete other ones\n\n    // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n    // You can use this, for example, to activate bindings on those nodes.\n\n    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n        // Map this array value inside a dependentObservable so we re-map when any dependency changes\n        var mappedNodes = [];\n        var dependentObservable = ko.dependentObservable(function() {\n            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];\n\n            // On subsequent evaluations, just replace the previously-inserted DOM nodes\n            if (mappedNodes.length > 0) {\n                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);\n                if (callbackAfterAddingNodes)\n                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);\n            }\n\n            // Replace the contents of the mappedNodes array, thereby updating the record\n            // of which nodes would be deleted if valueToMap was itself later removed\n            mappedNodes.length = 0;\n            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);\n        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });\n        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };\n    }\n\n    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),\n        deletedItemDummyValue = ko.utils.domData.nextKey();\n\n    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {\n        // Compare the provided array against the previous one\n        array = array || [];\n        options = options || {};\n        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;\n        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];\n        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });\n        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);\n\n        // Build the new mapping result\n        var newMappingResult = [];\n        var lastMappingResultIndex = 0;\n        var newMappingResultIndex = 0;\n\n        var nodesToDelete = [];\n        var itemsToProcess = [];\n        var itemsForBeforeRemoveCallbacks = [];\n        var itemsForMoveCallbacks = [];\n        var itemsForAfterAddCallbacks = [];\n        var mapData;\n\n        function itemMovedOrRetained(editScriptIndex, oldPosition) {\n            mapData = lastMappingResult[oldPosition];\n            if (newMappingResultIndex !== oldPosition)\n                itemsForMoveCallbacks[editScriptIndex] = mapData;\n            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray\n            mapData.indexObservable(newMappingResultIndex++);\n            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);\n            newMappingResult.push(mapData);\n            itemsToProcess.push(mapData);\n        }\n\n        function callCallback(callback, items) {\n            if (callback) {\n                for (var i = 0, n = items.length; i < n; i++) {\n                    if (items[i]) {\n                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {\n                            callback(node, i, items[i].arrayEntry);\n                        });\n                    }\n                }\n            }\n        }\n\n        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {\n            movedIndex = editScriptItem['moved'];\n            switch (editScriptItem['status']) {\n                case \"deleted\":\n                    if (movedIndex === undefined) {\n                        mapData = lastMappingResult[lastMappingResultIndex];\n\n                        // Stop tracking changes to the mapping for these nodes\n                        if (mapData.dependentObservable) {\n                            mapData.dependentObservable.dispose();\n                            mapData.dependentObservable = undefined;\n                        }\n\n                        // Queue these nodes for later removal\n                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {\n                            if (options['beforeRemove']) {\n                                newMappingResult.push(mapData);\n                                itemsToProcess.push(mapData);\n                                if (mapData.arrayEntry === deletedItemDummyValue) {\n                                    mapData = null;\n                                } else {\n                                    itemsForBeforeRemoveCallbacks[i] = mapData;\n                                }\n                            }\n                            if (mapData) {\n                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);\n                            }\n                        }\n                    }\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"retained\":\n                    itemMovedOrRetained(i, lastMappingResultIndex++);\n                    break;\n\n                case \"added\":\n                    if (movedIndex !== undefined) {\n                        itemMovedOrRetained(i, movedIndex);\n                    } else {\n                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };\n                        newMappingResult.push(mapData);\n                        itemsToProcess.push(mapData);\n                        if (!isFirstExecution)\n                            itemsForAfterAddCallbacks[i] = mapData;\n                    }\n                    break;\n            }\n        }\n\n        // Store a copy of the array items we just considered so we can difference it next time\n        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);\n\n        // Call beforeMove first before any changes have been made to the DOM\n        callCallback(options['beforeMove'], itemsForMoveCallbacks);\n\n        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)\n        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);\n\n        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)\n        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {\n            // Get nodes for newly added items\n            if (!mapData.mappedNodes)\n                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));\n\n            // Put nodes in the right place if they aren't there already\n            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {\n                if (node !== nextNode)\n                    ko.virtualElements.insertAfter(domNode, node, lastNode);\n            }\n\n            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)\n            if (!mapData.initialized && callbackAfterAddingNodes) {\n                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);\n                mapData.initialized = true;\n            }\n        }\n\n        // If there's a beforeRemove callback, call it after reordering.\n        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using\n        // some sort of animation, which is why we first reorder the nodes that will be removed. If the\n        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.\n        // Perhaps we'll make that change in the future if this scenario becomes more common.\n        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);\n\n        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item\n        // as already \"removed\" so we won't call beforeRemove for it again, and it ensures that the item won't match up\n        // with an actual item in the array and appear as \"retained\" or \"moved\".\n        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {\n            if (itemsForBeforeRemoveCallbacks[i]) {\n                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;\n            }\n        }\n\n        // Finally call afterMove and afterAdd callbacks\n        callCallback(options['afterMove'], itemsForMoveCallbacks);\n        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);\n    }\n})();\n\nko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);\n"]}