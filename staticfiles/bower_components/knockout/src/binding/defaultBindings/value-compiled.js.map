{"version":3,"sources":["../../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/binding/defaultBindings/value.js"],"names":[],"mappings":"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","file":"value-compiled.js","sourcesContent":["ko.bindingHandlers['value'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit\n        if (element.tagName.toLowerCase() == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });\n            return;\n        }\n\n        // Always catch \"change\" event; possibly other events too if asked\n        var eventsToCatch = [\"change\"];\n        var requestedEventsToCatch = allBindings.get(\"valueUpdate\");\n        var propertyChangedFired = false;\n        var elementValueBeforeEvent = null;\n\n        if (requestedEventsToCatch) {\n            if (typeof requestedEventsToCatch == \"string\") // Allow both individual event names, and arrays of event names\n                requestedEventsToCatch = [requestedEventsToCatch];\n            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);\n            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);\n        }\n\n        var valueUpdateHandler = function() {\n            elementValueBeforeEvent = null;\n            propertyChangedFired = false;\n            var modelValue = valueAccessor();\n            var elementValue = ko.selectExtensions.readValue(element);\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);\n        }\n\n        // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n        // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == \"input\" && element.type == \"text\"\n                                       && element.autocomplete != \"off\" && (!element.form || element.form.autocomplete != \"off\");\n        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, \"propertychange\") == -1) {\n            ko.utils.registerEventHandler(element, \"propertychange\", function () { propertyChangedFired = true });\n            ko.utils.registerEventHandler(element, \"focus\", function () { propertyChangedFired = false });\n            ko.utils.registerEventHandler(element, \"blur\", function() {\n                if (propertyChangedFired) {\n                    valueUpdateHandler();\n                }\n            });\n        }\n\n        ko.utils.arrayForEach(eventsToCatch, function(eventName) {\n            // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n            // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)\n            var handler = valueUpdateHandler;\n            if (ko.utils.stringStartsWith(eventName, \"after\")) {\n                handler = function() {\n                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between\n                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen\n                    // at the earliest asynchronous opportunity. We store this temporary information so that\n                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,\n                    // we can overwrite that model value change with the value the user just typed. Otherwise,\n                    // techniques like rateLimit can trigger model changes at critical moments that will\n                    // override the user's inputs, causing keystrokes to be lost.\n                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);\n                    ko.utils.setTimeout(valueUpdateHandler, 0);\n                };\n                eventName = eventName.substring(\"after\".length);\n            }\n            ko.utils.registerEventHandler(element, eventName, handler);\n        });\n\n        var updateFromModel = function () {\n            var newValue = ko.utils.unwrapObservable(valueAccessor());\n            var elementValue = ko.selectExtensions.readValue(element);\n\n            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateFromModel, 0);\n                return;\n            }\n\n            var valueHasChanged = (newValue !== elementValue);\n\n            if (valueHasChanged) {\n                if (ko.utils.tagNameLower(element) === \"select\") {\n                    var allowUnset = allBindings.get('valueAllowUnset');\n                    var applyValueAction = function () {\n                        ko.selectExtensions.writeValue(element, newValue, allowUnset);\n                    };\n                    applyValueAction();\n\n                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {\n                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n                        // because you're not allowed to have a model value that disagrees with a visible UI selection.\n                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                    } else {\n                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n                        // to apply the value as well.\n                        ko.utils.setTimeout(applyValueAction, 0);\n                    }\n                } else {\n                    ko.selectExtensions.writeValue(element, newValue);\n                }\n            }\n        };\n\n        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });\n    },\n    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding\n};\nko.expressionRewriting.twoWayBindings['value'] = true;\n"]}