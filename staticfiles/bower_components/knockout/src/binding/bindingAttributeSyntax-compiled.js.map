{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/binding/bindingAttributeSyntax.js"],"names":[],"mappings":"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","file":"bindingAttributeSyntax-compiled.js","sourcesContent":["(function () {\n    ko.bindingHandlers = {};\n\n    // The following element types will not be recursed into during binding.\n    var bindingDoesNotRecurseIntoElementTypes = {\n        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,\n        // because it's unexpected and a potential XSS issue.\n        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer\n        // and because such elements' contents are always intended to be bound in a different context\n        // from where they appear in the document.\n        'script': true,\n        'textarea': true,\n        'template': true\n    };\n\n    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers\n    ko['getBindingHandler'] = function(bindingKey) {\n        return ko.bindingHandlers[bindingKey];\n    };\n\n    // The ko.bindingContext constructor is only called directly to create the root context. For child\n    // contexts, use bindingContext.createChildContext or bindingContext.extend.\n    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback) {\n\n        // The binding context object includes static properties for the current, parent, and root view models.\n        // If a view model is actually stored in an observable, the corresponding binding context object, and\n        // any child contexts, must be updated when the view model is changed.\n        function updateContext() {\n            // Most of the time, the context will directly get a view model object, but if a function is given,\n            // we call the function to retrieve the view model. If the function accesses any observables or returns\n            // an observable, the dependency is tracked, and those observables can later cause the binding\n            // context to be updated.\n            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,\n                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);\n\n            if (parentContext) {\n                // When a \"parent\" context is given, register a dependency on the parent context. Thus whenever the\n                // parent context is updated, this context will also be updated.\n                if (parentContext._subscribable)\n                    parentContext._subscribable();\n\n                // Copy $root and any custom properties from the parent context\n                ko.utils.extend(self, parentContext);\n\n                // Because the above copy overwrites our own properties, we need to reset them.\n                // During the first execution, \"subscribable\" isn't set, so don't bother doing the update then.\n                if (subscribable) {\n                    self._subscribable = subscribable;\n                }\n            } else {\n                self['$parents'] = [];\n                self['$root'] = dataItem;\n\n                // Export 'ko' in the binding context so it will be available in bindings and templates\n                // even if 'ko' isn't exported as a global, such as when using an AMD loader.\n                // See https://github.com/SteveSanderson/knockout/issues/490\n                self['ko'] = ko;\n            }\n            self['$rawData'] = dataItemOrObservable;\n            self['$data'] = dataItem;\n            if (dataItemAlias)\n                self[dataItemAlias] = dataItem;\n\n            // The extendCallback function is provided when creating a child context or extending a context.\n            // It handles the specific actions needed to finish setting up the binding context. Actions in this\n            // function could also add dependencies to this binding context.\n            if (extendCallback)\n                extendCallback(self, parentContext, dataItem);\n\n            return self['$data'];\n        }\n        function disposeWhen() {\n            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);\n        }\n\n        var self = this,\n            isFunc = typeof(dataItemOrAccessor) == \"function\" && !ko.isObservable(dataItemOrAccessor),\n            nodes,\n            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });\n\n        // At this point, the binding context has been initialized, and the \"subscribable\" computed observable is\n        // subscribed to any observables that were accessed in the process. If there is nothing to track, the\n        // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in\n        // the context object.\n        if (subscribable.isActive()) {\n            self._subscribable = subscribable;\n\n            // Always notify because even if the model ($data) hasn't changed, other context properties might have changed\n            subscribable['equalityComparer'] = null;\n\n            // We need to be able to dispose of this computed observable when it's no longer needed. This would be\n            // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and\n            // we cannot assume that those nodes have any relation to each other. So instead we track any node that\n            // the context is attached to, and dispose the computed when all of those nodes have been cleaned.\n\n            // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates\n            nodes = [];\n            subscribable._addNode = function(node) {\n                nodes.push(node);\n                ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {\n                    ko.utils.arrayRemoveItem(nodes, node);\n                    if (!nodes.length) {\n                        subscribable.dispose();\n                        self._subscribable = subscribable = undefined;\n                    }\n                });\n            };\n        }\n    }\n\n    // Extend the binding context hierarchy with a new view model object. If the parent context is watching\n    // any observables, the new child context will automatically get a dependency on the parent context.\n    // But this does not mean that the $data value of the child context will also get updated. If the child\n    // view model also depends on the parent view model, you must provide a function that returns the correct\n    // view model on each update.\n    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback) {\n        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {\n            // Extend the context hierarchy by setting the appropriate pointers\n            self['$parentContext'] = parentContext;\n            self['$parent'] = parentContext['$data'];\n            self['$parents'] = (parentContext['$parents'] || []).slice(0);\n            self['$parents'].unshift(self['$parent']);\n            if (extendCallback)\n                extendCallback(self);\n        });\n    };\n\n    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.\n    // Similarly to \"child\" contexts, provide a function here to make sure that the correct values are set\n    // when an observable view model is updated.\n    ko.bindingContext.prototype['extend'] = function(properties) {\n        // If the parent context references an observable view model, \"_subscribable\" will always be the\n        // latest view model object. If not, \"_subscribable\" isn't set, and we can use the static \"$data\" value.\n        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {\n            // This \"child\" context doesn't directly track a parent observable view model,\n            // so we need to manually set the $rawData value to match the parent.\n            self['$rawData'] = parentContext['$rawData'];\n            ko.utils.extend(self, typeof(properties) == \"function\" ? properties() : properties);\n        });\n    };\n\n    // Returns the valueAccesor function for a binding value\n    function makeValueAccessor(value) {\n        return function() {\n            return value;\n        };\n    }\n\n    // Returns the value of a valueAccessor function\n    function evaluateValueAccessor(valueAccessor) {\n        return valueAccessor();\n    }\n\n    // Given a function that returns bindings, create and return a new object that contains\n    // binding value-accessors functions. Each accessor function calls the original function\n    // so that it always gets the latest value and all dependencies are captured. This is used\n    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.\n    function makeAccessorsFromFunction(callback) {\n        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {\n            return function() {\n                return callback()[key];\n            };\n        });\n    }\n\n    // Given a bindings function or object, create and return a new object that contains\n    // binding value-accessors functions. This is used by ko.applyBindingsToNode.\n    function makeBindingAccessors(bindings, context, node) {\n        if (typeof bindings === 'function') {\n            return makeAccessorsFromFunction(bindings.bind(null, context, node));\n        } else {\n            return ko.utils.objectMap(bindings, makeValueAccessor);\n        }\n    }\n\n    // This function is used if the binding provider doesn't include a getBindingAccessors function.\n    // It must be called with 'this' set to the provider instance.\n    function getBindingsAndMakeAccessors(node, context) {\n        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));\n    }\n\n    function validateThatBindingIsAllowedForVirtualElements(bindingName) {\n        var validator = ko.virtualElements.allowedBindings[bindingName];\n        if (!validator)\n            throw new Error(\"The binding '\" + bindingName + \"' cannot be used with virtual elements\")\n    }\n\n    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {\n        var currentChild,\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),\n            provider = ko.bindingProvider['instance'],\n            preprocessNode = provider['preprocessNode'];\n\n        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's\n        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to\n        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that\n        // trigger insertion of <template> contents at that point in the document.\n        if (preprocessNode) {\n            while (currentChild = nextInQueue) {\n                nextInQueue = ko.virtualElements.nextSibling(currentChild);\n                preprocessNode.call(provider, currentChild);\n            }\n            // Reset nextInQueue for the next loop\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);\n        }\n\n        while (currentChild = nextInQueue) {\n            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n            nextInQueue = ko.virtualElements.nextSibling(currentChild);\n            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);\n        }\n    }\n\n    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {\n        var shouldBindDescendants = true;\n\n        // Perf optimisation: Apply bindings only if...\n        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)\n        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those\n        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n        var isElement = (nodeVerified.nodeType === 1);\n        if (isElement) // Workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);\n\n        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)\n                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)\n        if (shouldApplyBindings)\n            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];\n\n        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {\n            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n            //    hence bindingContextsMayDifferFromDomParentElement is false\n            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n            //    hence bindingContextsMayDifferFromDomParentElement is true\n            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);\n        }\n    }\n\n    var boundElementDomDataKey = ko.utils.domData.nextKey();\n\n\n    function topologicalSortBindings(bindings) {\n        // Depth-first sort\n        var result = [],                // The list of key/handler pairs that we will return\n            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'\n            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {\n            if (!bindingsConsidered[bindingKey]) {\n                var binding = ko['getBindingHandler'](bindingKey);\n                if (binding) {\n                    // First add dependencies (if any) of the current binding\n                    if (binding['after']) {\n                        cyclicDependencyStack.push(bindingKey);\n                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {\n                            if (bindings[bindingDependencyKey]) {\n                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n                                    throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \" + cyclicDependencyStack.join(\", \"));\n                                } else {\n                                    pushBinding(bindingDependencyKey);\n                                }\n                            }\n                        });\n                        cyclicDependencyStack.length--;\n                    }\n                    // Next add the current binding\n                    result.push({ key: bindingKey, handler: binding });\n                }\n                bindingsConsidered[bindingKey] = true;\n            }\n        });\n\n        return result;\n    }\n\n    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {\n        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified\n        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);\n        if (!sourceBindings) {\n            if (alreadyBound) {\n                throw Error(\"You cannot apply bindings multiple times to the same element.\");\n            }\n            ko.utils.domData.set(node, boundElementDomDataKey, true);\n        }\n\n        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because\n        // we can easily recover it just by scanning up the node's ancestors in the DOM\n        // (note: here, parent node means \"real DOM parent\" not \"virtual parent\", as there's no O(1) way to find the virtual parent)\n        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)\n            ko.storedBindingContextForNode(node, bindingContext);\n\n        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n        var bindings;\n        if (sourceBindings && typeof sourceBindings !== 'function') {\n            bindings = sourceBindings;\n        } else {\n            var provider = ko.bindingProvider['instance'],\n                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;\n\n            // Get the binding from the provider within a computed observable so that we can update the bindings whenever\n            // the binding context is updated or if the binding provider accesses observables.\n            var bindingsUpdater = ko.dependentObservable(\n                function() {\n                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);\n                    // Register a dependency on the binding context to support observable view models.\n                    if (bindings && bindingContext._subscribable)\n                        bindingContext._subscribable();\n                    return bindings;\n                },\n                null, { disposeWhenNodeIsRemoved: node }\n            );\n\n            if (!bindings || !bindingsUpdater.isActive())\n                bindingsUpdater = null;\n        }\n\n        var bindingHandlerThatControlsDescendantBindings;\n        if (bindings) {\n            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding\n            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets\n            // the latest binding value and registers a dependency on the binding updater.\n            var getValueAccessor = bindingsUpdater\n                ? function(bindingKey) {\n                    return function() {\n                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);\n                    };\n                } : function(bindingKey) {\n                    return bindings[bindingKey];\n                };\n\n            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated\n            function allBindings() {\n                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);\n            }\n            // The following is the 3.x allBindings API\n            allBindings['get'] = function(key) {\n                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));\n            };\n            allBindings['has'] = function(key) {\n                return key in bindings;\n            };\n\n            // First put the bindings into the right order\n            var orderedBindings = topologicalSortBindings(bindings);\n\n            // Go through the sorted bindings, calling init and update for each\n            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {\n                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,\n                // so bindingKeyAndHandler.handler will always be nonnull.\n                var handlerInitFn = bindingKeyAndHandler.handler[\"init\"],\n                    handlerUpdateFn = bindingKeyAndHandler.handler[\"update\"],\n                    bindingKey = bindingKeyAndHandler.key;\n\n                if (node.nodeType === 8) {\n                    validateThatBindingIsAllowedForVirtualElements(bindingKey);\n                }\n\n                try {\n                    // Run init, ignoring any dependencies\n                    if (typeof handlerInitFn == \"function\") {\n                        ko.dependencyDetection.ignore(function() {\n                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n\n                            // If this binding handler claims to control descendant bindings, make a note of this\n                            if (initResult && initResult['controlsDescendantBindings']) {\n                                if (bindingHandlerThatControlsDescendantBindings !== undefined)\n                                    throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n                                bindingHandlerThatControlsDescendantBindings = bindingKey;\n                            }\n                        });\n                    }\n\n                    // Run update in its own computed wrapper\n                    if (typeof handlerUpdateFn == \"function\") {\n                        ko.dependentObservable(\n                            function() {\n                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n                            },\n                            null,\n                            { disposeWhenNodeIsRemoved: node }\n                        );\n                    }\n                } catch (ex) {\n                    ex.message = \"Unable to process binding \\\"\" + bindingKey + \": \" + bindings[bindingKey] + \"\\\"\\nMessage: \" + ex.message;\n                    throw ex;\n                }\n            });\n        }\n\n        return {\n            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined\n        };\n    };\n\n    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();\n    ko.storedBindingContextForNode = function (node, bindingContext) {\n        if (arguments.length == 2) {\n            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);\n            if (bindingContext._subscribable)\n                bindingContext._subscribable._addNode(node);\n        } else {\n            return ko.utils.domData.get(node, storedBindingContextDomDataKey);\n        }\n    }\n\n    function getBindingContext(viewModelOrBindingContext) {\n        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)\n            ? viewModelOrBindingContext\n            : new ko.bindingContext(viewModelOrBindingContext);\n    }\n\n    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {\n        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(node);\n        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);\n    };\n\n    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {\n        var context = getBindingContext(viewModelOrBindingContext);\n        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);\n    };\n\n    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {\n        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)\n            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {\n        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.\n        if (!jQueryInstance && window['jQuery']) {\n            jQueryInstance = window['jQuery'];\n        }\n\n        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))\n            throw new Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");\n        rootNode = rootNode || window.document.body; // Make \"rootNode\" parameter optional\n\n        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    // Retrieving binding context from arbitrary nodes\n    ko.contextFor = function(node) {\n        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n        switch (node.nodeType) {\n            case 1:\n            case 8:\n                var context = ko.storedBindingContextForNode(node);\n                if (context) return context;\n                if (node.parentNode) return ko.contextFor(node.parentNode);\n                break;\n        }\n        return undefined;\n    };\n    ko.dataFor = function(node) {\n        var context = ko.contextFor(node);\n        return context ? context['$data'] : undefined;\n    };\n\n    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);\n    ko.exportSymbol('applyBindings', ko.applyBindings);\n    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);\n    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);\n    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);\n    ko.exportSymbol('contextFor', ko.contextFor);\n    ko.exportSymbol('dataFor', ko.dataFor);\n})();\n"]}