{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/components/loaderRegistry.js"],"names":[],"mappings":"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","file":"loaderRegistry-compiled.js","sourcesContent":["(function(undefined) {\n    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight\n        loadedDefinitionsCache = {};    // Tracks component loads that have already completed\n\n    ko.components = {\n        get: function(componentName, callback) {\n            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);\n            if (cachedDefinition) {\n                // It's already loaded and cached. Reuse the same definition object.\n                // Note that for API consistency, even cache hits complete asynchronously by default.\n                // You can bypass this by putting synchronous:true on your component config.\n                if (cachedDefinition.isSynchronousComponent) {\n                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning\n                        callback(cachedDefinition.definition);\n                    });\n                } else {\n                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });\n                }\n            } else {\n                // Join the loading process that is already underway, or start a new one.\n                loadComponentAndNotify(componentName, callback);\n            }\n        },\n\n        clearCachedDefinition: function(componentName) {\n            delete loadedDefinitionsCache[componentName];\n        },\n\n        _getFirstResultFromLoaders: getFirstResultFromLoaders\n    };\n\n    function getObjectOwnProperty(obj, propName) {\n        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n    }\n\n    function loadComponentAndNotify(componentName, callback) {\n        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),\n            completedAsync;\n        if (!subscribable) {\n            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.\n            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();\n            subscribable.subscribe(callback);\n\n            beginLoadingComponent(componentName, function(definition, config) {\n                var isSynchronousComponent = !!(config && config['synchronous']);\n                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };\n                delete loadingSubscribablesCache[componentName];\n\n                // For API consistency, all loads complete asynchronously. However we want to avoid\n                // adding an extra task schedule if it's unnecessary (i.e., the completion is already\n                // async).\n                //\n                // You can bypass the 'always asynchronous' feature by putting the synchronous:true\n                // flag on your component configuration when you register it.\n                if (completedAsync || isSynchronousComponent) {\n                    // Note that notifySubscribers ignores any dependencies read within the callback.\n                    // See comment in loaderRegistryBehaviors.js for reasoning\n                    subscribable['notifySubscribers'](definition);\n                } else {\n                    ko.tasks.schedule(function() {\n                        subscribable['notifySubscribers'](definition);\n                    });\n                }\n            });\n            completedAsync = true;\n        } else {\n            subscribable.subscribe(callback);\n        }\n    }\n\n    function beginLoadingComponent(componentName, callback) {\n        getFirstResultFromLoaders('getConfig', [componentName], function(config) {\n            if (config) {\n                // We have a config, so now load its definition\n                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {\n                    callback(definition, config);\n                });\n            } else {\n                // The component has no config - it's unknown to all the loaders.\n                // Note that this is not an error (e.g., a module loading error) - that would abort the\n                // process and this callback would not run. For this callback to run, all loaders must\n                // have confirmed they don't know about this component.\n                callback(null, null);\n            }\n        });\n    }\n\n    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {\n        // On the first call in the stack, start with the full set of loaders\n        if (!candidateLoaders) {\n            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array\n        }\n\n        // Try the next candidate\n        var currentCandidateLoader = candidateLoaders.shift();\n        if (currentCandidateLoader) {\n            var methodInstance = currentCandidateLoader[methodName];\n            if (methodInstance) {\n                var wasAborted = false,\n                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {\n                        if (wasAborted) {\n                            callback(null);\n                        } else if (result !== null) {\n                            // This candidate returned a value. Use it.\n                            callback(result);\n                        } else {\n                            // Try the next candidate\n                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n                        }\n                    }));\n\n                // Currently, loaders may not return anything synchronously. This leaves open the possibility\n                // that we'll extend the API to support synchronous return values in the future. It won't be\n                // a breaking change, because currently no loader is allowed to return anything except undefined.\n                if (synchronousReturnValue !== undefined) {\n                    wasAborted = true;\n\n                    // Method to suppress exceptions will remain undocumented. This is only to keep\n                    // KO's specs running tidily, since we can observe the loading got aborted without\n                    // having exceptions cluttering up the console too.\n                    if (!currentCandidateLoader['suppressLoaderExceptions']) {\n                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');\n                    }\n                }\n            } else {\n                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.\n                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n            }\n        } else {\n            // No candidates returned a value\n            callback(null);\n        }\n    }\n\n    // Reference the loaders via string name so it's possible for developers\n    // to replace the whole array by assigning to ko.components.loaders\n    ko.components['loaders'] = [];\n\n    ko.exportSymbol('components', ko.components);\n    ko.exportSymbol('components.get', ko.components.get);\n    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);\n})();\n"]}