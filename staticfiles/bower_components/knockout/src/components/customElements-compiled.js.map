{"version":3,"sources":["../../../../../../../../../../../home/jan/workspace/django_shop/shop/staticfiles/bower_components/knockout/src/components/customElements.js"],"names":[],"mappings":"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","file":"customElements-compiled.js","sourcesContent":["(function (undefined) {\n    // Overridable API for determining which component name applies to a given node. By overriding this,\n    // you can for example map specific tagNames to components that are not preregistered.\n    ko.components['getComponentNameForNode'] = function(node) {\n        var tagNameLower = ko.utils.tagNameLower(node);\n        if (ko.components.isRegistered(tagNameLower)) {\n            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603\n            if (tagNameLower.indexOf('-') != -1 || ('' + node) == \"[object HTMLUnknownElement]\" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {\n                return tagNameLower;\n            }\n        }\n    };\n\n    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {\n        // Determine if it's really a custom element matching a component\n        if (node.nodeType === 1) {\n            var componentName = ko.components['getComponentNameForNode'](node);\n            if (componentName) {\n                // It does represent a component, so add a component binding for it\n                allBindings = allBindings || {};\n\n                if (allBindings['component']) {\n                    // Avoid silently overwriting some other 'component' binding that may already be on the element\n                    throw new Error('Cannot use the \"component\" binding on a custom element matching a component');\n                }\n\n                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };\n\n                allBindings['component'] = valueAccessors\n                    ? function() { return componentBindingValue; }\n                    : componentBindingValue;\n            }\n        }\n\n        return allBindings;\n    }\n\n    var nativeBindingProviderInstance = new ko.bindingProvider();\n\n    function getComponentParamsFromCustomElement(elem, bindingContext) {\n        var paramsAttribute = elem.getAttribute('params');\n\n        if (paramsAttribute) {\n            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),\n                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {\n                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });\n                }),\n                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {\n                    var paramValue = paramValueComputed.peek();\n                    // Does the evaluation of the parameter value unwrap any observables?\n                    if (!paramValueComputed.isActive()) {\n                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.\n                        // Example: \"someVal: firstName, age: 123\" (whether or not firstName is an observable/computed)\n                        return paramValue;\n                    } else {\n                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)\n                        // level of observability, and any inner (resulting model value) level of observability.\n                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a\n                        // writable observable, the computed will also be writable and pass the value on to the observable.\n                        return ko.computed({\n                            'read': function() {\n                                return ko.utils.unwrapObservable(paramValueComputed());\n                            },\n                            'write': ko.isWriteableObservable(paramValue) && function(value) {\n                                paramValueComputed()(value);\n                            },\n                            disposeWhenNodeIsRemoved: elem\n                        });\n                    }\n                });\n\n            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'\n            // This is in case the developer wants to react to outer (binding) observability separately from inner\n            // (model value) observability, or in case the model value observable has subobservables.\n            if (!result.hasOwnProperty('$raw')) {\n                result['$raw'] = rawParamComputedValues;\n            }\n\n            return result;\n        } else {\n            // For consistency, absence of a \"params\" attribute is treated the same as the presence of\n            // any empty one. Otherwise component viewmodels need special code to check whether or not\n            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.\n            return { '$raw': {} };\n        }\n    }\n\n    // --------------------------------------------------------------------------------\n    // Compatibility code for older (pre-HTML5) IE browsers\n\n    if (ko.utils.ieVersion < 9) {\n        // Whenever you preregister a component, enable it as a custom element in the current document\n        ko.components['register'] = (function(originalFunction) {\n            return function(componentName) {\n                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element\n                return originalFunction.apply(this, arguments);\n            }\n        })(ko.components['register']);\n\n        // Whenever you create a document fragment, enable all preregistered component names as custom elements\n        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements\n        document.createDocumentFragment = (function(originalFunction) {\n            return function() {\n                var newDocFrag = originalFunction(),\n                    allComponents = ko.components._allRegisteredComponents;\n                for (var componentName in allComponents) {\n                    if (allComponents.hasOwnProperty(componentName)) {\n                        newDocFrag.createElement(componentName);\n                    }\n                }\n                return newDocFrag;\n            };\n        })(document.createDocumentFragment);\n    }\n})();"]}